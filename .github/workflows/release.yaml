name: Release

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAMESPACE: scienceol

permissions:
  contents: write
  issues: write
  pull-requests: write
  packages: write

jobs:
  # Semantic Release
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
      new_release_git_tag: ${{ steps.semantic.outputs.new_release_git_tag }}
      build_start: ${{ steps.setup.outputs.build_start }}
      commit_author: ${{ steps.setup.outputs.commit_author }}
      commit_email: ${{ steps.setup.outputs.commit_email }}
      commit_message: ${{ steps.setup.outputs.commit_message }}
      commit_sha: ${{ steps.setup.outputs.commit_sha }}
      commit_sha_short: ${{ steps.setup.outputs.commit_sha_short }}
      commit_date: ${{ steps.setup.outputs.commit_date }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup build variables
        id: setup
        run: |
          echo "build_start=$(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_OUTPUT
          echo "commit_author=$(git log -1 --pretty=format:'%an')" >> $GITHUB_OUTPUT
          echo "commit_email=$(git log -1 --pretty=format:'%ae')" >> $GITHUB_OUTPUT
          echo "commit_message=$(git log -1 --pretty=format:'%s')" >> $GITHUB_OUTPUT
          echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "commit_sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "commit_date=$(git log -1 --pretty=format:'%cd' --date=format:'%Y-%m-%d %H:%M:%S')" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install dependencies
        run: |
          corepack enable
          yarn install --immutable

      - name: Semantic Release
        id: semantic
        uses: cycjimmy/semantic-release-action@v4
        env:
          GITHUB_TOKEN: ${{ secrets.SCIENCEOL_GITHUB_TOKEN }}

  # Build runner CLI binaries and upload to GitHub Release
  build-runner:
    name: Build Runner CLI
    needs: release
    if: needs.release.outputs.new_release_published == 'true'
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.release.outputs.new_release_version }}
      GIT_TAG: ${{ needs.release.outputs.new_release_git_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release.outputs.new_release_git_tag }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: runner/go.mod
          cache-dependency-path: runner/go.sum

      - name: Cross-compile for all platforms
        working-directory: runner
        run: make all VERSION=${{ env.VERSION }}

      - name: Upload binaries to GitHub Release
        env:
          GH_TOKEN: ${{ secrets.SCIENCEOL_GITHUB_TOKEN }}
        run: |
          gh release upload "${{ env.GIT_TAG }}" \
            runner/bin/xyzen-darwin-amd64 \
            runner/bin/xyzen-darwin-arm64 \
            runner/bin/xyzen-linux-amd64 \
            runner/bin/xyzen-linux-arm64 \
            runner/bin/xyzen-windows-amd64.exe \
            --clobber

      - name: Runner Build Summary
        run: |
          echo "## Runner CLI Binaries" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | Binary |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| macOS Intel | \`xyzen-darwin-amd64\` |" >> $GITHUB_STEP_SUMMARY
          echo "| macOS Apple Silicon | \`xyzen-darwin-arm64\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Linux x86_64 | \`xyzen-linux-amd64\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Linux ARM64 | \`xyzen-linux-arm64\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Windows x86_64 | \`xyzen-windows-amd64.exe\` |" >> $GITHUB_STEP_SUMMARY

  # Build service image per-platform (amd64 + arm64 in parallel)
  build-service:
    name: Build Service (${{ matrix.platform }})
    needs: release
    if: needs.release.outputs.new_release_published == 'true'
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}
    env:
      VERSION: ${{ needs.release.outputs.new_release_version }}
      GIT_TAG: ${{ needs.release.outputs.new_release_git_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release.outputs.new_release_git_tag }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.SCIENCEOL_GITHUB_TOKEN }}

      - name: Prepare platform pair
        id: platform
        run: echo "pair=${platform//\//-}" >> $GITHUB_OUTPUT
        env:
          platform: ${{ matrix.platform }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./service
          platforms: ${{ matrix.platform }}
          build-args: |
            XYZEN_VERSION=${{ env.VERSION }}
            XYZEN_COMMIT_SHA=${{ github.sha }}
            XYZEN_BUILD_TIME=${{ needs.release.outputs.commit_date }}
          outputs: type=image,"name=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service",push-by-digest=true,name-canonical=true,push=true
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:buildcache-${{ steps.platform.outputs.pair }}
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:buildcache-${{ steps.platform.outputs.pair }},mode=max

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: service-digest-${{ steps.platform.outputs.pair }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  # Build web image per-platform (amd64 + arm64 in parallel)
  build-web:
    name: Build Web (${{ matrix.platform }})
    needs: release
    if: needs.release.outputs.new_release_published == 'true'
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}
    env:
      VERSION: ${{ needs.release.outputs.new_release_version }}
      GIT_TAG: ${{ needs.release.outputs.new_release_git_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release.outputs.new_release_git_tag }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.SCIENCEOL_GITHUB_TOKEN }}

      - name: Prepare platform pair
        id: platform
        run: echo "pair=${platform//\//-}" >> $GITHUB_OUTPUT
        env:
          platform: ${{ matrix.platform }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./web
          platforms: ${{ matrix.platform }}
          build-args: |
            XYZEN_VERSION=${{ env.VERSION }}
          outputs: type=image,"name=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web",push-by-digest=true,name-canonical=true,push=true
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web:buildcache-${{ steps.platform.outputs.pair }}
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web:buildcache-${{ steps.platform.outputs.pair }},mode=max

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: web-digest-${{ steps.platform.outputs.pair }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  # Merge service multi-arch manifest
  merge-service:
    name: Merge Service Manifest
    runs-on: ubuntu-latest
    needs: [release, build-service]
    env:
      VERSION: ${{ needs.release.outputs.new_release_version }}
      GIT_TAG: ${{ needs.release.outputs.new_release_git_tag }}
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.SCIENCEOL_GITHUB_TOKEN }}

      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: service-digest-*
          merge-multiple: true

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create \
            --annotation "index:org.opencontainers.image.description=AI Research Interface" \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:latest \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:${{ env.VERSION }} \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:${{ env.GIT_TAG }} \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service@sha256:%s ' *)

  # Merge web multi-arch manifest
  merge-web:
    name: Merge Web Manifest
    runs-on: ubuntu-latest
    needs: [release, build-web]
    env:
      VERSION: ${{ needs.release.outputs.new_release_version }}
      GIT_TAG: ${{ needs.release.outputs.new_release_git_tag }}
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.SCIENCEOL_GITHUB_TOKEN }}

      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: web-digest-*
          merge-multiple: true

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create \
            --annotation "index:org.opencontainers.image.description=AI Research Interface" \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web:latest \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web:${{ env.VERSION }} \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web:${{ env.GIT_TAG }} \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web@sha256:%s ' *)

  # Deploy: Wait for all manifests to be ready
  deploy:
    name: Deploy
    needs: [release, merge-service, merge-web]
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.release.outputs.new_release_version }}
    steps:
      - name: Set up kubeconfig
        env:
          KUBE_CONFIG: ${{ secrets.SCIENCEOL_ACR_KUBE_CONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG" > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Deploy to Kubernetes
        run: |
          kubectl -n bohrium set image deployment/xyzen *=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:${{ env.VERSION }}
          kubectl -n bohrium set image deployment/xyzen-celery *=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:${{ env.VERSION }}
          kubectl -n sciol set image deployment/xyzen *=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:${{ env.VERSION }}
          kubectl -n sciol set image deployment/xyzen-web *=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web:${{ env.VERSION }}

      - name: Deployment Summary
        run: |
          echo "## ðŸš€ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Image |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Service | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:${{ env.VERSION }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Web | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web:${{ env.VERSION }}\` |" >> $GITHUB_STEP_SUMMARY

  # Notify: Send build result notification
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [release, merge-service, merge-web, deploy]
    if: always() && needs.release.outputs.new_release_published == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Calculate build duration
        id: duration
        run: |
          BUILD_START="${{ needs.release.outputs.build_start }}"
          if [ -z "$BUILD_START" ]; then
            BUILD_START=$(date '+%Y-%m-%d %H:%M:%S')
          fi

          BUILD_START_SEC=$(date -d "$BUILD_START" +%s)
          BUILD_END=$(date '+%Y-%m-%d %H:%M:%S')
          BUILD_END_SEC=$(date +%s)
          DURATION_SEC=$((BUILD_END_SEC - BUILD_START_SEC))

          HOURS=$((DURATION_SEC / 3600))
          MINUTES=$(((DURATION_SEC % 3600) / 60))
          SECONDS=$((DURATION_SEC % 60))

          echo "build_end=$BUILD_END" >> $GITHUB_OUTPUT
          echo "build_duration=${HOURS}h ${MINUTES}m ${SECONDS}s" >> $GITHUB_OUTPUT

      - name: Determine overall status
        id: status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

      - name: Send notification
        uses: ./.github/actions/email-notification
        with:
          status: ${{ steps.status.outputs.status }}
          smtp_server: smtp.feishu.cn
          smtp_port: 465
          smtp_user: ${{ secrets.SMTP_USER }}
          smtp_pass: ${{ secrets.SMTP_PASS }}
          recipient: ${{ secrets.SMTP_RECEIVER }}
          architecture: 'amd64,arm64'
          pr_number: 'N/A'
          pr_title: 'Release ${{ needs.release.outputs.new_release_git_tag }}'
          pr_url: '${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.release.outputs.new_release_git_tag }}'
          head_ref: ${{ github.ref_name }}
          base_ref: 'main'
          repo: ${{ github.repository }}
          run_id: ${{ github.run_id }}
          build_start: ${{ needs.release.outputs.build_start }}
          build_end: ${{ steps.duration.outputs.build_end }}
          build_duration: ${{ steps.duration.outputs.build_duration }}
          commit_author: ${{ needs.release.outputs.commit_author }}
          commit_email: ${{ needs.release.outputs.commit_email }}
          commit_message: ${{ needs.release.outputs.commit_message }}
          commit_sha: ${{ needs.release.outputs.commit_sha }}
          commit_sha_short: ${{ needs.release.outputs.commit_sha_short }}
          commit_date: ${{ needs.release.outputs.commit_date }}
          service_image: '${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-service:${{ needs.release.outputs.new_release_version }}'
          web_image: '${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/xyzen-web:${{ needs.release.outputs.new_release_version }}'

  # Recreate test branch from main after release
  # (GitHub auto-deletes test after PR merge; this recreates it for the next dev cycle)
  recreate-test:
    name: Recreate Test Branch
    needs: [release, deploy]
    if: needs.release.outputs.new_release_published == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 1
          token: ${{ secrets.SCIENCEOL_GITHUB_TOKEN }}

      - name: Create test branch from main
        run: git push --force origin HEAD:refs/heads/test
